<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Why Haskell?</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				  <section>
              <h1>Why Haskell?</h1>
              <h3>Brian Jones <a href="https://twitter.com/mojobojo">@mojobojo</a></h3>
          </section>
				  <section>
              <h3>Introduction</h3>
          </section>
				  <section>
              <h3>Haskell Motivation</h3>
              <section>
                  <p>Build complex, scalable, maintainable software systems.</p>
              </section>
              <section>
                  <p>Reduce programmer cognitive overload.</p>
                  <p class="fragment fade-in"><small>Produce easy to reason about code.</small></p>
                  <p class="fragment fade-in"><small>Focus on the small, not the large.</small></p>
              </section>
              <section>
                  <p>Reduce the number of bugs with strong compile time checks.</p>
                  <p class="fragment fade-in"><small>Prefer catching problems at compile time.</small></p>
                  <p class="fragment fade-in"><small>Reduce testing surface.</small></p>
              </section>
              <section>
                  <p>Utilize stong types to build correct software.</p>
                  <p class="fragment fade-in"><small>Describe complex domains.</small></p>
                  <p class="fragment fade-in"><small>Runtime guarantees.</small></p>
              </section>
              <section>
                  <p>Ease of long term maintenance.</p>
                  <p class="fragment fade-in"><small>Refactor heavily without fear.</small></p>
                  <p class="fragment fade-in"><small>Types help guide compilation.</small></p>
              </section>
              <section>
                  <p>Fast</p>
                  <p class="fragment fade-in"><small>Hand tuned code can reach C speeds.</small></p>
                  <p>Low memory</p>
                  <p class="fragment fade-in"><small>Although we have to watch out for "space leaks".</small></p>
                  <p>Binary</p>
                  <p class="fragment fade-in"><small>No runtime, deploy as-is.</small></p>
              </section>
          </section>
				  <section>
              <h3>Rumors</h3>
              <p>I heard it…</p>
              <section>
                  <p>Is a math language.</p>
                  <p>I have to learn lambda calculus to even use it.</p>
              </section>
              <section>
                  <p>Is a research language.</p>
                  <p>Only language researchers use it.</p>
              </section>
              <section>Is not used in production systems.</section>
              <section>Is incredibly hard to learn.</section>
              <section>Uses crazy terms like Monoid, Applicative, Monad.</section>
          </section>
				  <section>
              <h3>Concerns</h3>
              <section>
                  <p>Not a corporate backed programming language.</p>
                      <ul>
                          <li>Oracle (Sun) - Java</li>
                          <li>Microsoft - C#/F#</li>
                          <li>Google - Go</li>
                          <li>Ericsson - Erlang (Elixir)</li>
                          <li>Everyone - Javascript</li>
                      </ul>
              </section>
              <section>
                  <p>High learning curve.</p>
                  <p class="fragment shrink">If I don't grasp it in a day I will never be productive.</p>
              </section>
              <section>
                  <p>Smaller community compared to other popular languages.</p>
              </section>
          </section>
				  <section>
              <h3>Benefits</h3>
              <section>
                  <p>Pure.</p>
                  <p><small>Equational reasoning.</small></p>
              </section>
              <section>
                  <p>IO is separate.</p>
                  <p><small>Controlled side effects.</small></p>
              </section>
              <section>
                  <p>Strongly typed.</p>
                  <p><small>Hindley-Milner type system.</small></p>
                  <p><small>Algebraic Data Types.</small></p>
              </section>
              <section>
                  <p>Immutable.</p>
                  <p><small>No possibility of mis-referencing variables and stomping on data.</small></p>
              </section>
              <section>
                  <p>No NULL.</p>
                  <p><small>Compile time guarantees that your application won’t crash.</small></p>
              </section>
              <section>
                  <p>Functional.</p>
                  <p><small>Great abstractions.</small></p>
                  <p><small>More reusable code.</small></p>
              </section>
              <section>
                  <p>Lazy evaluation.</p>
                  <p><small>But strict when you want it.</small></p>
              </section>
          </section>
				  <section>
              <h3>Secret Weapon</h3>
              <p>Refactor with Impunity</p>
              <section>Come back to an old project 6-12 months later and dive right in.</section>
              <section>The compiler will guide you until everything builds cleanly.</section>
              <section>No more wondering if an unrelated sub-module will break in production.</section>
          </section>
				  <section>
              <h3>Compile Time Guarantees</h3>
              <blockquote>“If it compiles, it does exactly what you want.” -- Haskellers</blockquote>
              <section>Type safety makes it much harder to make mistakes.</section>
              <section>Pattern matching makes it impossible to pass non-compliant parameters to functions.</section>
              <section>
                  <p>No NULL.</p>
                  <p>Maybe and Either types allow all possible failure cases to be handled.</p>
                  <p class="fragment fade-in"><small>There's exception handlers too, but we'll skip those for now.</small></p>
              </section>
              <section>
                  <p>All code paths are checked for completeness.</p>
                  <p>Totality of application checked means no unhandled failures.</p>
              </section>
          </section>
				  <section>
              <h3>Purity</h3>
				      <section>
                  <div style="float:left;width:60%;">
                      C
                      <pre><code data-trim data-noescape>
                      int add(int a, int b) {
                        fireTheMissiles();
                        return a + b;
                      }
                      </code></pre>
                  </div>
                  <div style="float:right;width:40%;">
                      <img src="images/haskell_2x.png" style="width:50%;height:50%;"/>
                  </div>
              </section>
				      <section>
                  <p>IO</p>
                  <pre><code data-trim data-noescape>
                  add :: Int -> Int -> IO Int
                  add x y = do
                    fireTheMissiles
                    return (x + y)
                  </code></pre>
                  <p><small>This is of course possible, but...</small></p>
              </section>
				      <section>
                  <p>Pure</p>
                  <pre><code data-trim data-noescape>
                  add :: Int -> Int -> Int
                  add x y = x + y
                  </code></pre>
                  <p><small>It's impossible to call IO code in a pure function.</small></p>
              </section>
          </section>
				  <section>
              <h3>Algebraic Data Types</h3>
				      <section>
                  <pre><code data-trim data-noescape>
                  data Animal = Dog String | Cat String

                  talk :: Animal -> String
                  talk (Dog s) = "A dog says " ++ s
                  talk (Cat s) = "A cat says " ++ s

                  main :: IO ()
                  main = do
                    putStrLn . talk $ Dog "bark"
                    putStrLn . talk $ Cat "meow"
                  </code></pre>
				      </section>
				      <section>
                  <h4>Polymorphism</h3>
                  <pre><code data-trim data-noescape>
                  data Shape a = Circle a | Rectangle a a

                  area :: (Num a, Floating a) => Shape a -> a
                  area (Circle r)      = pi * (r ^ 2)
                  area (Rectangle w h) = w * l

                  main :: IO ()
                  main = do
                    putStrLn . show $ area (Circle 10)
                    putStrLn . show $ area (Rectangle 1.0 2.0)
                  </code></pre>
				      </section>
          </section>
				  <section>
              <h3>No NULL</h3>
				      <section>
                  <blockquote style="font-size:0.75em">I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years -- Tony Hoare</blockquote>
              </section>
				      <section>
                  <h4>Maybe</h3>
                  <pre><code data-trim data-noescape>
                  data Maybe a = Nothing | Just a

                  f :: Int -> Maybe Int
                  f 0 = Nothing
                  f x = Just x

                  main :: IO ()
                  main = case f 10 of
                           Nothing -> putStrLn "zero"
                           Just x  -> putStrLn $ show x
                  </code></pre>
              </section>
				      <section>
                  <h4>Either</h4>
                  <pre><code data-trim data-noescape>
                  data Either a b = Left a | Right b

                  f :: Int -> Either String Int
                  f 0 = Left "zero"
                  f x = Right x

                  main :: IO ()
                  main =
                    case f 10 of
                      Left s  -> putStrLn $ "fail: " ++ s
                      Right v -> putStrLn $ "success: " ++ show v
                  </code></pre>
              </section>
          </section>
				  <section>
              <h3>Functional</h3>
              <section>More focus on generality ends up with better abstractions.</section>
              <section>
                  <p>Less focus on <i>how</i> to manipulate data.</p>
                  <p>More on achieving the final result.</p>
              </section>
              <section>
                  <p>Higher level abstractions means less code.</p>
                  <p><small>Making it easier to reason about.</small></p>
              </section>
              <section>Composability.</section>
          </section>
				  <section>
              <h3>Functional vs. Imperative</h3>
				      <section>
                  <div style="float:left;width:50%;">
                      C
                      <pre><code data-trim data-noescape>
                      int x = 0;
                      for (int i = 0; i < 10; i++)
                      {
                        x += i;
                      }
                      </code></pre>
                      Haskell
                      <pre><code data-trim data-noescape>
                      let x = foldr (+) 0 [0..9]
                      </code></pre>
                  </div>
                  <div style="float:right;width:40%;">
                      <img src="images/functional_2x.png" class="right" style="width:50%;height:50%;"/>
                  </div>
              </section>
				      <section>
                  <h4>Composability</h4>
                  <pre><code data-trim data-noescape>
                  add(10, sub(5, div(6, 4)));
                  </code></pre>
                  vs
                  <pre><code data-trim data-noescape>
                  add 10 . sub 5 . div 6 $ 4
                  </code></pre>
                  <pre><code data-trim data-noescape>
                  let add10 = (+10)
                  add10 . sub 5 . div 6 $ 4
                  </code></pre>
              </section>
          </section>
				  <section>
              <h3>Tooling</h3>
              <a href="https://www.haskellstack.org">Stack</a>
				      <section>
                  <h4>New Project</h4>
                  <pre><code data-trim data-noescape>
                  stack new project
                  cd project
                  </code></pre>
              </section>
				      <section>
                  <h4>Configuration</h4>
                  <pre><code data-trim data-noescape>
                  # edit project.cabal -- libraries, build settings, etc.
                  # maybe edit stack.yaml -- one off libraries, settings, etc.
                  </code></pre>
              </section>
				      <section>
                  <h4>Usage</h4>
                  <pre><code data-trim data-noescape>
                  stack setup # one time thing -- pulls in compiler version
                  stack test # run tests
                  stack bench # run any code benchmarks
                  stack build # pulls in any new cabal deps and builds
                  stack install # build and install to local destination
                  </code></pre>
              </section>
          </section>
				  <section>
              <h3>Testing</h3>
              <ul>
                  <li><a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>: Property testing.</li>
                  <li><a href="https://hackage.haskell.org/package/hspec">HSpec</a>: Standard unit testing.</li>
                  <li><a href="https://hackage.haskell.org/package/tasty">Tasty</a>: Alternative.</li>
              </ul>
          </section>
				  <section>
              <h3>AlasConnect Tech Stack</h3>
              <p>Type check from the UI down to the DB</p>
              <section>
                  <h4>Key Libraries</h4>
                  <p>UI: <a href="https://hackage.haskell.org/package/reflex">reflex</a>/<a href="https://hackage.haskell.org/package/reflex-dom">reflex-dom</a> (FRP)</p>
                  <p>API: <a href="https://hackage.haskell.org/package/servant-server">servant</a> (<a href="https://haskell-servant.readthedocs.io">docs</a>)</p>
                  <p>DB: <a href="https://github.com/k0001/tisch">tisch</a> (PostgreSQL)</p>
                  <p><small>(<a href="http://ren.zone/articles/opaleye-sot">explanation</a>) (<a href="https://hackage.haskell.org/package/opaleye">opaleye</a>)</small></p>
              </section>
              <section>
                  <h4>Additional Libraries</h4>
                  <p>JSON/Yaml: <a href="https://hackage.haskell.org/package/aeson">aeson</a></p>
                  <p>Encryption: <a href="https://hackage.haskell.org/package/scrypt">scrypt</a></p>
              </section>
          </section>
				  <section>
              <h3>AlasConnect Tech Stack</h3>
              <section>
                  <p>Frontend and backend share common logic allowing for reuse of code.</p>
                  <p>(No split brain)</p>
              </section>
              <section>Frontend compiles to a single page application with GHCJS.</section>
              <section>Backend compiles to a binary with GHC and exposes a REST API.</section>
          </section>
				  <section>
              <h3>Database - Tisch (Opaleye)</h3>
				      <section>
                  <p>Explicit typing constrains table types.</p>
                  <pre><code data-trim data-noescape>
                  data Db1
                  data TUser
                  data instance Table TUser      = TUser
                  type instance Database TUser   = Db1
                  type instance SchemaName TUser = "public"
                  type instance TableName TUser  = "users"

                  newtype UserId = UserId { unUserId :: Int32 }
                  -- and a few more instances to help with tisch logic
                  </code></pre>
              </section>
				      <section>
                  <p>Define columns as Haskell types.</p>
                  <pre><code data-trim data-noescape>
                  type instance Columns TUser =
                    [ 'Column "user_id"   'WD 'R  UserId        UserId
                    , 'Column "username"  'W  'R  Username      Username
                    , 'Column "password"  'W  'R  PasswordE     PasswordE
                    , 'Column "email"     'W  'R  Email         Email
                    , 'Column "verify_t"  'W  'R  Token         Token
                    , 'Column "verified"  'WD 'R  PGBool        Bool
                    , 'Column "created"   'WD 'R  PGTimestamptz UTCTime
                    , 'Column "logged_in" 'WD 'R  PGTimestamptz UTCTime
                    ]
                  </code></pre>
                  <p>Or keep them as raw PG types.</p>
              </section>
				      <section>
                  <p>Generate completely type safe SQL.</p>
                  <pre><code data-trim data-noescape>
                  userQueryById :: UserId -> Query Db1 () (PgR TUser)
                  userQueryById uid = proc () -> do
                    u <- query TUser -< ()
                    restrict -< eq (#user_id u) (kol uid)
                    returnA -< u

                  userFetch :: (MonadIO m, MonadThrow m) =>
                               UserId -> Conn' -> m (Maybe (HsR TUser))
                  userFetch uid conn = runQuery1 conn (userQueryById uid)
                  </code></pre>
              </section>
          </section>
				  <section>
              <h3>API - Servant</h3>
				      <section>
                  <p>Type constrained APIs.</p>
                  <pre><code data-trim data-noescape>
                  type UserGet =
                    AppAuth :> Capture "id" UserId :> Get '[JSON] (Maybe UserR)
                  type UserInsert =
                    ReqBody '[JSON] UserW :> Post '[JSON] (Maybe UserR)
                  type UserUpdate =
                    AppAuth :> ReqBody '[JSON] UserU :> Put '[JSON] ()
                  </code></pre>
              </section>
				      <section>
                  <p>Simple business logic.</p>
                  <pre><code data-trim data-noescape>
                  getUser :: Maybe Session -> UserId -> AppM (Maybe UserR)
                  getUser ms uid =
                    withSession ms $ \_ ->
                      getConn >>= userFetch uid >>= mapM (pure . hsRToUserR)

                  insertUser :: UserW -> AppM (Maybe UserR)
                  insertUser u = do
                    r <- userInsert u =<< getConn
                    case r of
                      Left e   -> throwError err400 { errBody = pack . show $ e }
                      Right r' -> mapM (pure . hsRToUserR) r'
                  </code></pre>
              </section>
          </section>
				  <section>
              <h3>UI - Reflex</h3>
              <pre><code data-trim data-noescape>
             </code></pre>
          </section>
				  <section>
              <h3>JSON - Aeson</h3>
				      <section>
                  <p>Standard Haskell records (structs).</p>
                  <pre><code data-trim data-noescape>
                  data UserR
                    = UserR
                    { _urUserId   :: UserId
                    , _urUsername :: Username
                    , _urPassword :: PasswordE
                    , _urEmail    :: Email
                    , _urVerified :: Bool
                    , _urCreated  :: UTCTime
                    , _urLoggedIn :: UTCTime
                    } deriving (Show, Eq)
                  </code></pre>
              </section>
				      <section>
                  <pre><code data-trim data-noescape>
                  instance ToJSON UserR where
                    toJSON u =
                      object [ "user_id"   .= (u ^. urUserId)
                             , "username"  .= (u ^. urUsername)
                             , "email"     .= (u ^. urEmail)
                             , "verified"  .= (u ^. urVerified)
                             , "created"   .= (u ^. urCreated)
                             , "logged_in" .= (u ^. urLoggedIn)
                             ]
                  </code></pre>
              </section>
				      <section>
                  <pre><code data-trim data-noescape>
                  instance FromJSON UserW where
                    parseJSON (Object v) = UserW
                      <$> (v .: "username"  >>= vUsn)
                      <*> (v .: "password0" >>= vPwd)
                      <*> (v .: "password1" >>= vPwd)
                      <*> (v .: "email"     >>= vEml)
                      where
                        val  = either (fail . show) (pure . fromJust)
                        vUsn = val . validateUsername
                        vPwd = val . validatePassword
                        vEml = val . validateEmail
                    parseJSON _ = mzero
                  </code></pre>
              </section>
				      <section>
                  <h4>Validation</h4>
                  <pre><code data-trim data-noescape>
                  validateUsername :: Maybe Username ->
                                      Either ValidationError (Maybe Username)
                  validateUsername u@(Just (Username v))
                    | l < 3     = Left $ TooShort "username" l
                    | l > 30    = Left $ TooLong "username" l
                    | otherwise = Right u
                    where
                      l = T.length v
                  validateUsername _ = Right Nothing
                  </code></pre>
              </section>
          </section>
				  <section>
              <h3>Conclusion</h3>
              <section>
                  <p>Steep initial learning curve.</p>
                  <p>Extremely high payoff.</p>
              </section>
          </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
