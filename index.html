<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Why Haskell?</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				  <section>
              <h1>Why Haskell?</h1>
              <h3>Brian Jones <a href="https://twitter.com/mojobojo">@mojobojo</a></h3>
          </section>
				  <section>
              <h3>Introduction</h3>
          </section>
				  <section>
              <h3>Haskell Motivation</h3>
              <section>
                  <p>Build complex, scalable, maintainable software systems.</p>
              </section>
              <section>
                  <p>Reduce programmer cognitive overload.</p>
                  <p class="fragment fade-in"><small>Produce easy to reason about code.</small></p>
                  <p class="fragment fade-in"><small>Focus on the small, not the large.</small></p>
              </section>
              <section>
                  <p>Reduce the number of bugs with strong compile time checks.</p>
                  <p class="fragment fade-in"><small>Prefer catching problems at compile time.</small></p>
                  <p class="fragment fade-in"><small>Reduce testing surface.</small></p>
              </section>
              <section>
                  <p>Utilize stong types to build correct software.</p>
                  <p class="fragment fade-in"><small>Describe complex domains.</small></p>
                  <p class="fragment fade-in"><small>Runtime guarantees.</small></p>
              </section>
              <section>
                  <p>Ease of long term maintenance.</p>
                  <p class="fragment fade-in"><small>Refactor heavily without fear.</small></p>
                  <p class="fragment fade-in"><small>Types help guide compilation.</small></p>
              </section>
              <section>
                  <p>Fast</p>
                  <p class="fragment fade-in"><small>Hand tuned code can reach C speeds.</small></p>
                  <p>Low memory</p>
                  <p class="fragment fade-in"><small>Although we have to watch out for "space leaks".</small></p>
                  <p>Binary</p>
                  <p class="fragment fade-in"><small>No runtime, deploy as-is.</small></p>
              </section>
          </section>
				  <section>
              <h3>Rumors</h3>
              <p>I heard it…</p>
              <section>
                  <p>Is a math language.</p>
                  <p>I have to learn lambda calculus to even use it.</p>
              </section>
              <section>
                  <p>Is a research language.</p>
                  <p>Only language researchers use it.</p>
              </section>
              <section>Is not used in production systems.</section>
              <section>Is incredibly hard to learn.</section>
              <section>Uses crazy terms like Monoid, Applicative, Monad.</section>
          </section>
				  <section>
              <h3>Concerns</h3>
              <section>
                  <p>Not a corporate backed programming language.</p>
                      <ul>
                          <li>Oracle (Sun) - Java</li>
                          <li>Microsoft - C#/F#</li>
                          <li>Google - Go</li>
                          <li>Ericsson - Erlang (Elixir)</li>
                          <li>Everyone - Javascript</li>
                      </ul>
              </section>
              <section>
                  <p>High learning curve.</p>
                  <p class="fragment shrink">If I don't grasp it in a day I will never be productive.</p>
              </section>
              <section>
                  <p>Smaller community compared to other popular languages.</p>
              </section>
          </section>
				  <section>
              <h3>Benefits</h3>
              <section>
                  <p>Pure.</p>
                  <p><small>Equational reasoning.</small></p>
              </section>
              <section>
                  <p>IO is separate.</p>
                  <p><small>Controlled side effects.</small></p>
              </section>
              <section>
                  <p>Strongly typed.</p>
                  <p><small>Hindley-Milner type system.</small></p>
                  <p><small>Algebraic Data Types.</small></p>
              </section>
              <section>
                  <p>Immutable.</p>
                  <p><small>No possibility of mis-referencing variables and stomping on data.</small></p>
              </section>
              <section>
                  <p>No NULL.</p>
                  <p><small>Compile time guarantees that your application won’t crash.</small></p>
              </section>
              <section>
                  <p>Functional.</p>
                  <p><small>Great abstractions.</small></p>
                  <p><small>More reusable code.</small></p>
              </section>
              <section>
                  <p>Lazy evaluation.</p>
                  <p><small>But strict when you want it.</small></p>
              </section>
          </section>
				  <section>
              <h3>Secret Weapon</h3>
              <p>Refactor with Impunity</p>
              <section>Come back to an old project 6-12 months later and dive right in.</section>
              <section>The compiler will guide you until everything builds cleanly.</section>
              <section>No more wondering if an unrelated sub-module will break in production.</section>
          </section>
				  <section>
              <h3>Compile Time Guarantees</h3>
              <blockquote>“If it compiles, it does exactly what you want.” -- Haskellers</blockquote>
              <section>Type safety makes it much harder to make mistakes.</section>
              <section>Pattern matching makes it impossible to pass non-compliant parameters to functions.</section>
              <section>
                  <p>No NULL.</p>
                  <p>Maybe and Either types allow all possible failure cases to be handled.</p>
                  <p class="fragment fade-in"><small>There's exception handlers too, but we'll skip those for now.</small></p>
              </section>
              <section>
                  <p>All code paths are checked for completeness.</p>
                  <p>Totality of application checked means no unhandled failures.</p>
              </section>
          </section>
				  <section>
              <h3>Purity</h3>
				      <section>
                  <div style="float:left;width:60%;">
                      C
                      <pre><code class="haskell" data-trim data-noescape>
                      int add(int a, int b) {
                        fireTheMissiles();
                        return a + b;
                      }
                      </code></pre>
                  </div>
                  <div style="float:right;width:40%;">
                      <img src="images/haskell_2x.png" style="width:50%;height:50%;"/>
                  </div>
              </section>
				      <section>
                  <p>IO</p>
                  <pre><code class="haskell" data-trim data-noescape>
                  add :: Int -> Int -> IO Int
                  add x y = do
                    fireTheMissiles
                    return (x + y)
                  </code></pre>
                  <p><small>This is of course possible, but...</small></p>
              </section>
				      <section>
                  <p>Pure</p>
                  <pre><code class="haskell" data-trim data-noescape>
                  add :: Int -> Int -> Int
                  add x y = x + y
                  </code></pre>
                  <p><small>It's impossible to call IO code in a pure function.</small></p>
              </section>
          </section>
				  <section>
              <h3>Algebraic Data Types</h3>
				      <section>
                  <pre><code class="haskell" data-trim data-noescape>
                  data Status = Open | Closed | Canceled String
                  -----------   -------------------------------
                  Type          Constructors
                  </code></pre>
                  <pre><code class="haskell" data-trim data-noescape>
                  data Tree a = Nil | Node (Tree a) a (Tree a)
                  -----------
                  Polymorphism
                  </code></pre>
				      </section>
				      <section>
                  <pre><code class="haskell" data-trim data-noescape>
                  data Animal = Dog String | Cat String

                  talk :: Animal -> String
                  talk (Dog s) = "A dog says " ++ s
                  talk (Cat s) = "A cat says " ++ s

                  main :: IO ()
                  main = do
                    putStrLn . talk $ Dog "bark"
                    putStrLn . talk $ Cat "meow"
                  </code></pre>
				      </section>
				      <section>
                  <h4>Polymorphism</h3>
                  <pre><code class="haskell" data-trim data-noescape>
                  data Shape a = Circle a | Rectangle a a

                  area :: (Num a, Floating a) => Shape a -> a
                  area (Circle r)      = pi * (r ^ 2)
                  area (Rectangle w h) = w * l

                  main :: IO ()
                  main = do
                    putStrLn . show $ area (Circle 10)
                    putStrLn . show $ area (Rectangle 1.0 2.0)
                  </code></pre>
				      </section>
          </section>
				  <section>
              <h3>No NULL</h3>
				      <section>
                  <blockquote style="font-size:0.75em">I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years -- Tony Hoare</blockquote>
              </section>
				      <section>
                  <h4>Maybe</h3>
                  <pre><code class="haskell" data-trim data-noescape>
                  data Maybe a = Nothing | Just a

                  f :: Int -> Maybe Int
                  f 0 = Nothing
                  f x = Just x

                  main :: IO ()
                  main = case f 10 of
                           Nothing -> putStrLn "zero"
                           Just x  -> putStrLn $ show x
                  </code></pre>
              </section>
				      <section>
                  <h4>Either</h4>
                  <pre><code class="haskell" data-trim data-noescape>
                  data Either a b = Left a | Right b

                  f :: Int -> Either String Int
                  f 0 = Left "zero"
                  f x = Right x

                  main :: IO ()
                  main =
                    case f 10 of
                      Left s  -> putStrLn $ "fail: " ++ s
                      Right v -> putStrLn $ "success: " ++ show v
                  </code></pre>
              </section>
          </section>
				  <section>
              <h3>Functional</h3>
              <section>
                  <p>More focus on generality ends up with better abstractions.</p>
              </section>
              <section>
                  <p>Higher level abstractions means less code.</p>
                  <p><small>Making it easier to reason about.</small></p>
              </section>
              <section>
                  <p>Less focus on <i>how</i> to manipulate data.</p>
                  <p>More on achieving the final result.</p>
              </section>
          </section>
				  <section>
              <h3>Functional vs. Imperative</h3>
				      <section>
                  <div style="float:left;width:50%;">
                      C
                      <pre><code class="haskell" data-trim data-noescape>
                      int x = 0;
                      for (int i = 0; i < 10; i++)
                      {
                        x += i;
                      }
                      </code></pre>
                      Haskell
                      <pre><code class="haskell" data-trim data-noescape>
                      let x = foldr (+) 0 [0..9]
                      </code></pre>
                  </div>
                  <div style="float:right;width:40%;">
                      <img src="images/functional_2x.png" class="right" style="width:50%;height:50%;"/>
                  </div>
              </section>
				      <section>
                  <h4>Composability</h4>
                  <pre><code class="haskell" data-trim data-noescape>
                  add(10, sub(5, div(6, 4)));
                  </code></pre>
                  vs
                  <pre><code class="haskell" data-trim data-noescape>
                  add 10 . sub 5 . div 6 $ 4
                  </code></pre>
                  <pre><code class="haskell" data-trim data-noescape>
                  let add10 = (+10)
                  add10 . sub 5 . div 6 $ 4
                  </code></pre>
              </section>
				      <section>
                  <h4>Imperative Style</h4>
                  <pre><code class="haskell" data-trim data-noescape>
                  add :: IO ()
                  add = do
                    x <- getLine
                    y <- getLine
                    return (read x + read y)
                  </code></pre>
                  vs
                  <pre><code class="haskell" data-trim data-noescape>
                  add :: IO ()
                  add = getLine >>= \x -> getLine >>= \y ->
                        return (read x + read y)
                  </code></pre>
              </section>
          </section>
				  <section>
				      <section>
                  <h4>Haskell</h4>
                  <pre><code class="haskell" data-trim data-noescape>
                  main = do
                      putStrLn "Hello. What is your name?"
                      x <- getLine
                      putStrLn ("The input was " ++ x)
                  </code></pre>
                  <p><small><a href="https://e.xtendo.org/monad#25">https://e.xtendo.org/monad#25</a></small></p>
              </section>
          </section>
				  <section>
				      <section>
                  <h4>Python</h4>
                  <pre><code class="python" data-trim data-noescape>
                  if __name__ == '__main__':
                      print   ('Hello. What is your name?')
                      x = input()
                      print    ('The input was ' + x)
                  </code></pre>
                  <p><small><a href="https://e.xtendo.org/monad#26">https://e.xtendo.org/monad#26</a></small></p>
              </section>
          </section>
				  <section>
              <h3>Tooling</h3>
              <a href="https://www.haskellstack.org">Stack</a>
				      <section>
                  <h4>New Project</h4>
                  <pre><code class="bash" data-trim data-noescape>
                  stack new project
                  cd project
                  </code></pre>
              </section>
				      <section>
                  <h4>Configuration</h4>
                  <pre><code class="bash" data-trim data-noescape>
                  # edit project.cabal -- libraries, build settings, etc.
                  # maybe edit stack.yaml -- one off libraries, settings, etc.
                  </code></pre>
              </section>
				      <section>
                  <h4>Usage</h4>
                  <pre><code class="bash" data-trim data-noescape>
                  stack setup # one time thing -- pulls in compiler version
                  stack test # run tests
                  stack bench # run any code benchmarks
                  stack build # pulls in any new cabal deps and builds
                  stack install # build and install to local destination
                  </code></pre>
              </section>
          </section>
				  <section>
              <h3>Testing</h3>
              <ul>
                  <li><a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>: Property testing.</li>
                  <li><a href="https://hackage.haskell.org/package/hspec">HSpec</a>: Standard unit testing.</li>
                  <li><a href="https://hackage.haskell.org/package/tasty">Tasty</a>: Alternative.</li>
              </ul>
          </section>
				  <section>
              <h3>Conclusion</h3>
              <section>
                  <p>Steep initial learning curve.</p>
                  <p>Extremely high long term payoff.</p>
              </section>
          </section>
          <section>
              <h3>Homework</h3>
              <section>
                  <h4>Reading</h4>
                  <p><a href="http://haskellbook.com">Haskell Book</a></p>
                  <h4>Communities</h4>
                  <p><a href="https://www.reddit.com/r/haskell/">/r/haskell</a></p>
                  <p><a href="https://wiki.haskell.org/Mailing_lists">haskell-cafe@haskell.org</a></p>
                  <h4>Example</h4>
                  <p><a href="https://github.com/alasconnect/discover">https://github.com/alasconnect/discover</a></p>
              </section>
          </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
